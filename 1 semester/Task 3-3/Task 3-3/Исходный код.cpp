#include <iostream>
#include <ctime>

using namespace std;

/* Сортировка расческой - сложность алгоритма: О (n log n)
Основная идея «расчёски» в том, чтобы первоначально брать достаточно большое расстояние
между сравниваемыми элементами и по мере упорядочивания массива сужать это расстояние
вплоть до минимального. Первоначальный разрыв между сравниваемыми элементами лучше брать
с учётом специальной величины, называемой фактором уменьшения, оптимальное значение которой
равно примерно 1,247. Сначала расстояние между элементами равно размеру массива,
разделённого на фактор уменьшения (результат округляется до ближайшего целого).
Затем, пройдя массив с этим шагом, необходимо поделить шаг на фактор уменьшения и пройти по списку вновь.
Так продолжается до тех пор, пока разность индексов не достигнет единицы.
В этом случае массив досортировывается обычным пузырьком
*/

void combSort(int array[], int number)
{
	int jump = number;
	while (jump > 1)
	{
		if (jump > 1)
		{
			jump /= 1.247;
		}
		for (int i = 0; i + jump < number; i++)
		{
			if (array[i + jump] < array[i])
			{
				swap(array[i], array[i + jump]);
			}
		}
	}
}

/* Ищем наиболее часто встречающийся элемент в массиве.
При этом у нас уже массив отсортирован в порядке возрастания,
т.к. эта функция вызывается в главной функции после функции combSort
count - переменная, с помощью которой мы будем отслеживать количество одинаковых элементов в массиве
maximum - переменная, с помощью которой мы будем определять максимальное количество одинаковых элементов
Дальше идет первый цикл, в ходе которого мы находим самое большое количество одинаковых элементов.
Но нужно учесть, что у нас могут встретиться различные элементы одинаковое число раз.
Например: 1 1 1 2 2 3 3 3 4 (три единицы и три тройки), а нам нужно вывести один наиболее часто встречающийся элемент.
Поэтому нужен второй цикл
k - переменная, с помощью которой мы будем смотреть, какое кол-во различных элементов встречаются одинаковое число раз
mexElement - переменная, которая будет являться значением самого частого встречающегося элемента в массиве
В ходе второго цикла мы подсчитываем k. Если k равно единице, т.е. только один элемент встречается больше всех остальных,
то выводим этот элемент, иначе пишем, что нет элемента, встречающегося больше других
*/

void mostFrequentElement(int number, int array[])
{
	int count = 1;
	int maximum = 1;
	for (int i = 0; i < number - 1; i++)
	{
		if (array[i] == array[i + 1])
		{
			count++;
			if (count > maximum)
			{
				maximum = count;
			}
		}
		else
		{
			count = 1;
		}
	}
	count = 1;
	int k = 0;
	int maxElement = 0;
	for (int i = 0; i < number - 1; i++)
	{
		if (array[i] == array[i + 1])
		{
			count++;
			if (count == maximum)
			{
				k++;
				maxElement = array[i];
			}
		}
		else
		{
			count = 1;
		}
	}
	if (k == 1)
	{
		cout << "Наиболее часто встречающийся элемент в массиве: " << maxElement;
	}
	else
	{
		cout << "Нет наиболее часто встречающегося элемента в массиве";
	}
}

/* Считываем количество элементов в массиве. Затем заполянем элементы массива случайными числами и выводим массив
Диапазон чисел выбрал от 0 до 10 для того, чтобы легче было проверить правильность выполнения программы
Далее вызываем две вышеперечисленные функции
*/

int main()
{
	setlocale(0, "");
	srand(time(nullptr));
	int const index = 100;
	int array[index] = { 0 };
	int number = 0;
	cout << "Введите количество элементв в массиве: ";
	cin >> number;
	for (int i = 0; i < number; i++)
	{
		array[i] = rand() % 10;
	}
	cout << "Массив случайных чисел: ";
	for (int i = 0; i < number; i++)
	{
		cout << array[i] << " ";
	}
	cout << endl;
	combSort(array, number);
	mostFrequentElement(number, array);
	cout << endl;
	return 0;
}

/* При вводе 6, программа вывела: 7 2 9 2 4 1, наиболее часто встречающийся элемент: 2
При вводе 7, пограмма вывела: 2 1 2 4 3 4 0, "Нет наиболее часто встречающегося элемента в массиве"
*/